function|script|magic_register
{
    //debugmes ">> Register " + .invocation$ + " @ " + strnpcinfo(0);
    set .@ext$, if_then_else(getarg(0,"") != "", "::"+getarg(0), "");
    registercmd .invocation$, strnpcinfo(0) + .@ext$; // register the spell
    set .index, $@magic_index;
    set $@magic_index, $@magic_index + 1;
    return;
}

// this can only be done with a npc so...
-|script|Magic Timer|32767
{
    end;

OnLogin:
    set @_M_BLOCK, 2;
    //if (MAGIC_EXPERIENCE < 0)
    //    set MAGIC_EXPERIENCE, 0; // bug fix
    // ^ XXX: check if negative MAGIC_EXPERIENCE is desirable
    addtimer 10000, "Magic Timer::OnClear";
    end;

OnClear:
    set @_M_BLOCK, 0;
    end;
}

// this function is call()-only
function|script|magic_checks
{
    set .@flags, getarg(0);
    set .@nonmagic, .@flags & (1<<0);

    if (GM >= 50) goto L_Return; // event managers have no restrictions
    if(HIDDEN) goto L_Hidden; // can not cast with @hide
    if(@_M_BLOCK == 2) goto L_Login; // login warmup
    if(@_M_BLOCK) goto L_Blocked; // check if last debuff ended
    if(Hp < 1) goto L_Dead; // can not cast when dead
    if (MATK1 < 1 && .@nonmagic < 1) goto L_Greybar; // can not cast with a grey mana bar
    return 0;

L_Hidden:
    smsg SMSG_FAILURE, "Magic: Impossible to cast while hidden!";
    return 1;

L_Blocked:
    smsg SMSG_FAILURE, "Magic: Impossible to cast while a cooldown is in effect. Please wait.";
    return 2;

L_Dead:
    smsg SMSG_FAILURE, "Magic: Impossible to cast while dead!";
    return 3;

L_Greybar:
    smsg SMSG_FAILURE, "Magic: Impossible to cast with 0 m.atk. This might happen if your mana bar is grey. Some equipment can reduce your m.atk.";
    return 4;

L_Login:
    smsg SMSG_FAILURE, "Magic: Impossible to cast for 10s after logging in.";
    return 5;

L_Return:
    return 0;
}

function|script|elt_damage
{
    // args are damage, dmgplus(mutation), bonus_elt, malus_elt, effect
    set .@dmg, getarg(0) + rand(getarg(1));
    if(get(ELTTYPE, @target_id) == getarg(3)) // malus
        set .@dmg, .@dmg / 3;
    if(get(ELTTYPE, @target_id) == getarg(2)) // bonus
        set .@dmg, ((get(ELTLVL, @target_id) + 4) * .@dmg) / 4;
    set .@source, .caster;
    if (!.@source) set .@source, getcharid(3);

    injure .@source, @target_id, (.@dmg * (100 - get(MDEF1, @target_id))) / 100;
    if (getarg(4) != FX_NONE) misceffect getarg(4), @target_id;
    return;
}

function|script|melee_damage
{
    // args are spell power, target id, dmg
    if ((getarg(0) - rand(100)) < (get(BaseLevel, getarg(1)) + get(MDEF1, getarg(1))))
        injure BL_ID, getarg(1), 0;
    else injure BL_ID, getarg(1), (getarg(2) * (100 - get(MDEF1, @target_id))) / 100;
    return;
}

function|script|magic_create_item
{
    // FIXME / XXX: IMO, using Luk for this is very bad and unfair
    set .@exp, (MAGIC_EXPERIENCE & (BYTE_0_MASK | BYTE_1_MASK)) >> BYTE_0_SHIFT;
    set .@score, (.@exp + rand(min(@spellpower, ((.@exp / 3) + 1))));
    set @create_params[2], 1; // success flag
    if (.@score >= @create_params[1]) goto L_Perfect;
    set @create_params[2], 0; // success flag
    set .@score, .@score + rand(Luk) + rand(Luk);
    if (.@score < (@create_params[1] / 3)) goto L_Backfire;
    if (.@score < ((@create_params[1] * 2) / 3)) goto L_Iten;
    message strcharinfo(0), "Magic : ##3##BYour spell takes on a mind of its own!";
    if (rand(3) == 1) getitem @create_items$[1], 1; // bad item
    return;

L_Iten:
    if (rand(5) != 2) goto L_Escape;
    message strcharinfo(0), "Magic : ##3##BYour spell solidifies into the shape of a mysterious object!";
    getitem "Iten", 1;
    return;

L_Escape:
    message strcharinfo(0), "Magic : ##3##BYour spell escapes!";
    return;

L_Backfire:
    message strcharinfo(0), "Magic : ##3##BYour spell backfires!";
    if (rand(110) < Luk) heal max(0 - Hp + 1, 0 - ((BaseLevel+1)*(BaseLevel+2)*(rand(28)+3))), 0;
    else                 heal max(0 - Hp + 1, 0 - (BaseLevel + 1)), 0;
    if (Hp <= 2) goto L_Warp;
    return;

L_Warp:
    warp getsavepoint(0), getsavepoint(1), getsavepoint(2);
    return;

L_Perfect:
    getitem @create_items$[0], @create_params[0]; // good item
    return;
}

function|script|bit
{
    //0 name
    //1 mask
    //2 shift
    //3 value

    return ((getarg(0) & ~(getarg(1) << getarg(2))) | ((getarg(3) & getarg(1)) << getarg(2)));
}

function|script|magic_exp
{
    set @last_index, (MAGIC_EXPERIENCE >> 16) & 0xFF;
    set @last_exp, MAGIC_EXPERIENCE & 0xFFFF;

    //debugmes "old spell index: " + @last_index;
    //debugmes "new spell index: " + .index;

    if(getskilllv(SKILL_MAGIC) < (.level + 3) && .index != @last_index)
        goto L_Gain;
    //debugmes "same as last spell => don't proceed";
    goto L_Return;

L_Gain:
    if(.exp_gain < 1) goto L_Return; // only the spells that have exp register here. If you
    //                                 remove this line then players can cast a spell with
    //                                 no cost, then a spell with a reagents, then another
    //                                 spell with no costs and still get the exp
    set @new_exp, min(0xFFFF, @last_exp + .exp_gain);
    //debugmes "old magic exp: "+ @last_exp;
    //debugmes "new magic exp: "+ @new_exp;
    set MAGIC_EXPERIENCE, call("bit", MAGIC_EXPERIENCE, 0xFFFF, 0, @new_exp);
    set MAGIC_EXPERIENCE, call("bit", MAGIC_EXPERIENCE, 0xFF, 16, .index);
    goto L_Return;

L_Return:
    return;
}

function|script|adjust_spellpower
{
    set @spellpower, MATK1 + getskilllv(SKILL_MAGIC) + getskilllv(.school) + 10;
    if((.school != SKILL_MAGIC_NATURE) && (.school != SKILL_MAGIC_LIFE)) goto L_Return;
    if(@args$ == "" || !@args$ || getpartnerid2() == 0) goto L_Return;
    if(getcharid(3, @args$) < 1 || getpartnerid2() != getcharid(3, @args$) || !(isloggedin(getcharid(3, @args$))))
        goto L_Return;
    //debugmes "You targeted your spouse!";
    // XXX: the spell power increases when the target is the spouse so one could
    //      just do #modrilax (spouse) right?
    //
    // ... let's just forget about spouse for now
    goto L_Return;

L_Return:
    return;
}

function|script|gain_heal_xp
{
    set .@value, getarg(0);
    set .@gain, getarg(1);
    set .@value_divisor, getarg(2);
    set .@base_xp_factor, getarg(3);

    set .@last_heal_xp, ((MAGIC_EXPERIENCE >> 24) & 0xFF);

    if ((.@value / .@value_divisor) <= (10 + .@last_heal_xp + rand(.@last_heal_xp + 1) + rand(.@last_heal_xp + 1)))
        goto L_Return;

    set .@heal_xp, min(0xFF, .@last_heal_xp + .@gain); // XXX: maybe switch to 7F

    getexp (.@base_xp_factor * .@heal_xp), 0;

    // FIXME: extract_heal_xp

    //debugmes "old heal exp: "+ .@last_heal_xp;

    set MAGIC_EXPERIENCE, call("bit", MAGIC_EXPERIENCE, 0xFF, 24, .@heal_xp);

    //debugmes "new heal exp: "+ ((MAGIC_EXPERIENCE >> 24) & 0xFF);
    return 1;

L_Return:
    return 0;
}
